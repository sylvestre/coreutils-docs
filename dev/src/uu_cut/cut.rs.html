<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src/uu/cut/src/cut.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>cut.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../normalize.css"><link rel="stylesheet" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../ayu.css" disabled><link rel="stylesheet" href="../../dark.css" disabled><link rel="stylesheet" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><main><div class="width-limiter"><nav class="sub"><a class="sub-logo-container" href="../../uu_cut/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><pre class="src-line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
<span id="546">546</span>
<span id="547">547</span>
<span id="548">548</span>
<span id="549">549</span>
<span id="550">550</span>
<span id="551">551</span>
<span id="552">552</span>
<span id="553">553</span>
<span id="554">554</span>
<span id="555">555</span>
<span id="556">556</span>
<span id="557">557</span>
<span id="558">558</span>
<span id="559">559</span>
<span id="560">560</span>
<span id="561">561</span>
<span id="562">562</span>
<span id="563">563</span>
<span id="564">564</span>
<span id="565">565</span>
<span id="566">566</span>
<span id="567">567</span>
<span id="568">568</span>
<span id="569">569</span>
<span id="570">570</span>
<span id="571">571</span>
<span id="572">572</span>
<span id="573">573</span>
<span id="574">574</span>
<span id="575">575</span>
<span id="576">576</span>
<span id="577">577</span>
<span id="578">578</span>
<span id="579">579</span>
<span id="580">580</span>
<span id="581">581</span>
<span id="582">582</span>
<span id="583">583</span>
<span id="584">584</span>
<span id="585">585</span>
<span id="586">586</span>
<span id="587">587</span>
<span id="588">588</span>
<span id="589">589</span>
<span id="590">590</span>
<span id="591">591</span>
<span id="592">592</span>
<span id="593">593</span>
<span id="594">594</span>
<span id="595">595</span>
<span id="596">596</span>
<span id="597">597</span>
<span id="598">598</span>
<span id="599">599</span>
<span id="600">600</span>
<span id="601">601</span>
<span id="602">602</span>
<span id="603">603</span>
<span id="604">604</span>
<span id="605">605</span>
<span id="606">606</span>
<span id="607">607</span>
<span id="608">608</span>
<span id="609">609</span>
<span id="610">610</span>
<span id="611">611</span>
<span id="612">612</span>
<span id="613">613</span>
<span id="614">614</span>
<span id="615">615</span>
<span id="616">616</span>
<span id="617">617</span>
<span id="618">618</span>
<span id="619">619</span>
<span id="620">620</span>
<span id="621">621</span>
<span id="622">622</span>
<span id="623">623</span>
<span id="624">624</span>
<span id="625">625</span>
<span id="626">626</span>
<span id="627">627</span>
<span id="628">628</span>
<span id="629">629</span>
<span id="630">630</span>
<span id="631">631</span>
<span id="632">632</span>
<span id="633">633</span>
<span id="634">634</span>
<span id="635">635</span>
<span id="636">636</span>
<span id="637">637</span>
<span id="638">638</span>
<span id="639">639</span>
<span id="640">640</span>
<span id="641">641</span>
<span id="642">642</span>
<span id="643">643</span>
<span id="644">644</span>
<span id="645">645</span>
<span id="646">646</span>
<span id="647">647</span>
<span id="648">648</span>
<span id="649">649</span>
<span id="650">650</span>
<span id="651">651</span>
<span id="652">652</span>
<span id="653">653</span>
<span id="654">654</span>
<span id="655">655</span>
<span id="656">656</span>
<span id="657">657</span>
<span id="658">658</span>
<span id="659">659</span>
<span id="660">660</span>
<span id="661">661</span>
<span id="662">662</span>
<span id="663">663</span>
<span id="664">664</span>
<span id="665">665</span>
<span id="666">666</span>
<span id="667">667</span>
<span id="668">668</span>
<span id="669">669</span>
<span id="670">670</span>
<span id="671">671</span>
<span id="672">672</span>
<span id="673">673</span>
<span id="674">674</span>
<span id="675">675</span>
<span id="676">676</span>
<span id="677">677</span>
<span id="678">678</span>
<span id="679">679</span>
<span id="680">680</span>
<span id="681">681</span>
<span id="682">682</span>
<span id="683">683</span>
<span id="684">684</span>
<span id="685">685</span>
<span id="686">686</span>
<span id="687">687</span>
<span id="688">688</span>
<span id="689">689</span>
<span id="690">690</span>
<span id="691">691</span>
<span id="692">692</span>
<span id="693">693</span>
<span id="694">694</span>
<span id="695">695</span>
<span id="696">696</span>
<span id="697">697</span>
<span id="698">698</span>
<span id="699">699</span>
<span id="700">700</span>
<span id="701">701</span>
<span id="702">702</span>
<span id="703">703</span>
<span id="704">704</span>
<span id="705">705</span>
<span id="706">706</span>
<span id="707">707</span>
<span id="708">708</span>
<span id="709">709</span>
<span id="710">710</span>
<span id="711">711</span>
<span id="712">712</span>
<span id="713">713</span>
<span id="714">714</span>
<span id="715">715</span>
<span id="716">716</span>
<span id="717">717</span>
<span id="718">718</span>
<span id="719">719</span>
<span id="720">720</span>
<span id="721">721</span>
<span id="722">722</span>
<span id="723">723</span>
<span id="724">724</span>
<span id="725">725</span>
<span id="726">726</span>
<span id="727">727</span>
<span id="728">728</span>
<span id="729">729</span>
<span id="730">730</span>
<span id="731">731</span>
</pre><pre class="rust"><code><span class="comment">// This file is part of the uutils coreutils package.
//
// (c) Rolf Morel &lt;rolfmorel@gmail.com&gt;
//
// For the full copyright and license information, please view the LICENSE
// file that was distributed with this source code.

// spell-checker:ignore (ToDO) delim sourcefiles

</span><span class="kw">use </span>bstr::io::BufReadExt;
<span class="kw">use </span>clap::{crate_version, Arg, ArgAction, Command};
<span class="kw">use </span>std::fs::File;
<span class="kw">use </span>std::io::{stdin, stdout, BufReader, BufWriter, Read, Write};
<span class="kw">use </span>std::path::Path;
<span class="kw">use </span>uucore::display::Quotable;
<span class="kw">use </span>uucore::error::{FromIo, UResult, USimpleError};

<span class="kw">use </span><span class="self">self</span>::searcher::Searcher;
<span class="kw">use </span><span class="self">self</span>::whitespace_searcher::WhitespaceSearcher;
<span class="kw">use </span>uucore::ranges::Range;
<span class="kw">use </span>uucore::{format_usage, show, show_error, show_if_err};

<span class="kw">mod </span>searcher;
<span class="kw">mod </span>whitespace_searcher;

<span class="kw">static </span>USAGE: <span class="kw-2">&amp;</span>str =
    <span class="string">&quot;{} [-d|-w] [-s] [-z] [--output-delimiter] ((-f|-b|-c) {{sequence}}) {{sourcefile}}+&quot;</span>;
<span class="kw">static </span>ABOUT: <span class="kw-2">&amp;</span>str =
    <span class="string">&quot;Prints specified byte or field columns from each line of stdin or the input files&quot;</span>;
<span class="kw">static </span>LONG_HELP: <span class="kw-2">&amp;</span>str = <span class="string">&quot;
 Each call must specify a mode (what to use for columns),
 a sequence (which columns to print), and provide a data source

 Specifying a mode

    Use --bytes (-b) or --characters (-c) to specify byte mode

    Use --fields (-f) to specify field mode, where each line is broken into
    fields identified by a delimiter character. For example for a typical CSV
    you could use this in combination with setting comma as the delimiter

 Specifying a sequence

    A sequence is a group of 1 or more numbers or inclusive ranges separated
    by a commas.

    cut -f 2,5-7 some_file.txt
    will display the 2nd, 5th, 6th, and 7th field for each source line

    Ranges can extend to the end of the row by excluding the the second number

    cut -f 3- some_file.txt
    will display the 3rd field and all fields after for each source line

    The first number of a range can be excluded, and this is effectively the
    same as using 1 as the first number: it causes the range to begin at the
    first column. Ranges can also display a single column

    cut -f 1,3-5 some_file.txt
    will display the 1st, 3rd, 4th, and 5th field for each source line

    The --complement option, when used, inverts the effect of the sequence

    cut --complement -f 4-6 some_file.txt
    will display the every field but the 4th, 5th, and 6th

 Specifying a data source

    If no sourcefile arguments are specified, stdin is used as the source of
    lines to print

    If sourcefile arguments are specified, stdin is ignored and all files are
    read in consecutively if a sourcefile is not successfully read, a warning
    will print to stderr, and the eventual status code will be 1, but cut
    will continue to read through proceeding sourcefiles

    To print columns from both STDIN and a file argument, use - (dash) as a
    sourcefile argument to represent stdin.

 Field Mode options

    The fields in each line are identified by a delimiter (separator)

    Set the delimiter
        Set the delimiter which separates fields in the file using the
        --delimiter (-d) option. Setting the delimiter is optional.
        If not set, a default delimiter of Tab will be used.

        If the -w option is provided, fields will be separated by any number
        of whitespace characters (Space and Tab). The output delimiter will
        be a Tab unless explicitly specified. Only one of -d or -w option can be specified.
        This is an extension adopted from FreeBSD.

    Optionally Filter based on delimiter
        If the --only-delimited (-s) flag is provided, only lines which
        contain the delimiter will be printed

    Replace the delimiter
        If the --output-delimiter option is provided, the argument used for
        it will replace the delimiter character in each line printed. This is
        useful for transforming tabular data - e.g. to convert a CSV to a
        TSV (tab-separated file)

 Line endings

    When the --zero-terminated (-z) option is used, cut sees \\0 (null) as the
    &#39;line ending&#39; character (both for the purposes of reading lines and
    separating printed lines) instead of \\n (newline). This is useful for
    tabular data where some of the cells may contain newlines

    echo &#39;ab\\0cd&#39; | cut -z -c 1
    will result in &#39;a\\0c\\0&#39;
&quot;</span>;

<span class="kw">struct </span>Options {
    out_delim: <span class="prelude-ty">Option</span>&lt;String&gt;,
    zero_terminated: bool,
}

<span class="kw">enum </span>Delimiter {
    Whitespace,
    String(String), <span class="comment">// FIXME: use char?
</span>}

<span class="kw">struct </span>FieldOptions {
    delimiter: Delimiter,
    out_delimiter: <span class="prelude-ty">Option</span>&lt;String&gt;,
    only_delimited: bool,
    zero_terminated: bool,
}

<span class="kw">enum </span>Mode {
    Bytes(Vec&lt;Range&gt;, Options),
    Characters(Vec&lt;Range&gt;, Options),
    Fields(Vec&lt;Range&gt;, FieldOptions),
}

<span class="kw">fn </span>stdout_writer() -&gt; Box&lt;<span class="kw">dyn </span>Write&gt; {
    <span class="kw">if </span>atty::is(atty::Stream::Stdout) {
        Box::new(stdout())
    } <span class="kw">else </span>{
        Box::new(BufWriter::new(stdout())) <span class="kw">as </span>Box&lt;<span class="kw">dyn </span>Write&gt;
    }
}

<span class="kw">fn </span>list_to_ranges(list: <span class="kw-2">&amp;</span>str, complement: bool) -&gt; <span class="prelude-ty">Result</span>&lt;Vec&lt;Range&gt;, String&gt; {
    <span class="kw">if </span>complement {
        Range::from_list(list).map(|r| uucore::ranges::complement(<span class="kw-2">&amp;</span>r))
    } <span class="kw">else </span>{
        Range::from_list(list)
    }
}

<span class="kw">fn </span>cut_bytes&lt;R: Read&gt;(reader: R, ranges: <span class="kw-2">&amp;</span>[Range], opts: <span class="kw-2">&amp;</span>Options) -&gt; UResult&lt;()&gt; {
    <span class="kw">let </span>newline_char = <span class="kw">if </span>opts.zero_terminated { <span class="string">b&#39;\0&#39; </span>} <span class="kw">else </span>{ <span class="string">b&#39;\n&#39; </span>};
    <span class="kw">let </span><span class="kw-2">mut </span>buf_in = BufReader::new(reader);
    <span class="kw">let </span><span class="kw-2">mut </span>out = stdout_writer();
    <span class="kw">let </span>delim = opts
        .out_delim
        .as_ref()
        .map_or(<span class="string">&quot;&quot;</span>, String::as_str)
        .as_bytes();

    <span class="kw">let </span>result = buf_in.for_byte_record(newline_char, |line| {
        <span class="kw">let </span><span class="kw-2">mut </span>print_delim = <span class="bool-val">false</span>;
        <span class="kw">for </span><span class="kw-2">&amp;</span>Range { low, high } <span class="kw">in </span>ranges {
            <span class="kw">if </span>low &gt; line.len() {
                <span class="kw">break</span>;
            }
            <span class="kw">if </span>print_delim {
                out.write_all(delim)<span class="question-mark">?</span>;
            } <span class="kw">else if </span>opts.out_delim.is_some() {
                print_delim = <span class="bool-val">true</span>;
            }
            <span class="comment">// change `low` from 1-indexed value to 0-index value
            </span><span class="kw">let </span>low = low - <span class="number">1</span>;
            <span class="kw">let </span>high = high.min(line.len());
            out.write_all(<span class="kw-2">&amp;</span>line[low..high])<span class="question-mark">?</span>;
        }
        out.write_all(<span class="kw-2">&amp;</span>[newline_char])<span class="question-mark">?</span>;
        <span class="prelude-val">Ok</span>(<span class="bool-val">true</span>)
    });

    <span class="kw">if let </span><span class="prelude-val">Err</span>(e) = result {
        <span class="kw">return </span><span class="prelude-val">Err</span>(USimpleError::new(<span class="number">1</span>, e.to_string()));
    }

    <span class="prelude-val">Ok</span>(())
}

<span class="attribute">#[allow(clippy::cognitive_complexity)]
</span><span class="kw">fn </span>cut_fields_delimiter&lt;R: Read&gt;(
    reader: R,
    ranges: <span class="kw-2">&amp;</span>[Range],
    delim: <span class="kw-2">&amp;</span>str,
    only_delimited: bool,
    newline_char: u8,
    out_delim: <span class="kw-2">&amp;</span>str,
) -&gt; UResult&lt;()&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>buf_in = BufReader::new(reader);
    <span class="kw">let </span><span class="kw-2">mut </span>out = stdout_writer();
    <span class="kw">let </span>input_delim_len = delim.len();

    <span class="kw">let </span>result = buf_in.for_byte_record_with_terminator(newline_char, |line| {
        <span class="kw">let </span><span class="kw-2">mut </span>fields_pos = <span class="number">1</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>low_idx = <span class="number">0</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>delim_search = Searcher::new(line, delim.as_bytes()).peekable();
        <span class="kw">let </span><span class="kw-2">mut </span>print_delim = <span class="bool-val">false</span>;

        <span class="kw">if </span>delim_search.peek().is_none() {
            <span class="kw">if </span>!only_delimited {
                out.write_all(line)<span class="question-mark">?</span>;
                <span class="kw">if </span>line[line.len() - <span class="number">1</span>] != newline_char {
                    out.write_all(<span class="kw-2">&amp;</span>[newline_char])<span class="question-mark">?</span>;
                }
            }

            <span class="kw">return </span><span class="prelude-val">Ok</span>(<span class="bool-val">true</span>);
        }

        <span class="kw">for </span><span class="kw-2">&amp;</span>Range { low, high } <span class="kw">in </span>ranges {
            <span class="kw">if </span>low - fields_pos &gt; <span class="number">0 </span>{
                low_idx = <span class="kw">match </span>delim_search.nth(low - fields_pos - <span class="number">1</span>) {
                    <span class="prelude-val">Some</span>(index) =&gt; index + input_delim_len,
                    <span class="prelude-val">None </span>=&gt; <span class="kw">break</span>,
                };
            }

            <span class="kw">for _ in </span><span class="number">0</span>..=high - low {
                <span class="kw">if </span>print_delim {
                    out.write_all(out_delim.as_bytes())<span class="question-mark">?</span>;
                } <span class="kw">else </span>{
                    print_delim = <span class="bool-val">true</span>;
                }

                <span class="kw">match </span>delim_search.next() {
                    <span class="prelude-val">Some</span>(high_idx) =&gt; {
                        <span class="kw">let </span>segment = <span class="kw-2">&amp;</span>line[low_idx..high_idx];

                        out.write_all(segment)<span class="question-mark">?</span>;

                        low_idx = high_idx + input_delim_len;
                        fields_pos = high + <span class="number">1</span>;
                    }
                    <span class="prelude-val">None </span>=&gt; {
                        <span class="kw">let </span>segment = <span class="kw-2">&amp;</span>line[low_idx..];

                        out.write_all(segment)<span class="question-mark">?</span>;

                        <span class="kw">if </span>line[line.len() - <span class="number">1</span>] == newline_char {
                            <span class="kw">return </span><span class="prelude-val">Ok</span>(<span class="bool-val">true</span>);
                        }
                        <span class="kw">break</span>;
                    }
                }
            }
        }

        out.write_all(<span class="kw-2">&amp;</span>[newline_char])<span class="question-mark">?</span>;
        <span class="prelude-val">Ok</span>(<span class="bool-val">true</span>)
    });

    <span class="kw">if let </span><span class="prelude-val">Err</span>(e) = result {
        <span class="kw">return </span><span class="prelude-val">Err</span>(USimpleError::new(<span class="number">1</span>, e.to_string()));
    }

    <span class="prelude-val">Ok</span>(())
}

<span class="kw">fn </span>cut_fields_whitespace&lt;R: Read&gt;(
    reader: R,
    ranges: <span class="kw-2">&amp;</span>[Range],
    only_delimited: bool,
    newline_char: u8,
    out_delim: <span class="kw-2">&amp;</span>str,
) -&gt; UResult&lt;()&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>buf_in = BufReader::new(reader);
    <span class="kw">let </span><span class="kw-2">mut </span>out = stdout_writer();

    <span class="kw">let </span>result = buf_in.for_byte_record_with_terminator(newline_char, |line| {
        <span class="kw">let </span><span class="kw-2">mut </span>fields_pos = <span class="number">1</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>low_idx = <span class="number">0</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>delim_search = WhitespaceSearcher::new(line).peekable();
        <span class="kw">let </span><span class="kw-2">mut </span>print_delim = <span class="bool-val">false</span>;

        <span class="kw">if </span>delim_search.peek().is_none() {
            <span class="kw">if </span>!only_delimited {
                out.write_all(line)<span class="question-mark">?</span>;
                <span class="kw">if </span>line[line.len() - <span class="number">1</span>] != newline_char {
                    out.write_all(<span class="kw-2">&amp;</span>[newline_char])<span class="question-mark">?</span>;
                }
            }

            <span class="kw">return </span><span class="prelude-val">Ok</span>(<span class="bool-val">true</span>);
        }
        <span class="comment">// The logic is identical to `cut_fields_delimiter` function above, which uses
        // `Searcher` that iterates over and returns the first position of the delimiter character.
        // The main difference is that `WhitespaceSearcher` returns a pair of the first and last
        // delimiter character positions, since each delimiter sequence length can vary.
        </span><span class="kw">for </span><span class="kw-2">&amp;</span>Range { low, high } <span class="kw">in </span>ranges {
            <span class="kw">if </span>low - fields_pos &gt; <span class="number">0 </span>{
                <span class="comment">// current field is not in the range, so jump to the field corresponding to the
                // beginning of the range if any
                </span>low_idx = <span class="kw">match </span>delim_search.nth(low - fields_pos - <span class="number">1</span>) {
                    <span class="prelude-val">Some</span>((<span class="kw">_</span>, last)) =&gt; last,
                    <span class="prelude-val">None </span>=&gt; <span class="kw">break</span>,
                };
            }

            <span class="comment">// at this point, current field is the first in the range
            </span><span class="kw">for _ in </span><span class="number">0</span>..=high - low {
                <span class="comment">// skip printing delimiter if this is the first matching field for this line
                </span><span class="kw">if </span>print_delim {
                    out.write_all(out_delim.as_bytes())<span class="question-mark">?</span>;
                } <span class="kw">else </span>{
                    print_delim = <span class="bool-val">true</span>;
                }

                <span class="kw">match </span>delim_search.next() {
                    <span class="comment">// print the current field up to the next whitespace
                    </span><span class="prelude-val">Some</span>((first, last)) =&gt; {
                        <span class="kw">let </span>segment = <span class="kw-2">&amp;</span>line[low_idx..first];

                        out.write_all(segment)<span class="question-mark">?</span>;

                        low_idx = last;
                        fields_pos = high + <span class="number">1</span>;
                    }
                    <span class="prelude-val">None </span>=&gt; {
                        <span class="comment">// this is the last field in the line, so print the rest
                        </span><span class="kw">let </span>segment = <span class="kw-2">&amp;</span>line[low_idx..];

                        out.write_all(segment)<span class="question-mark">?</span>;

                        <span class="kw">if </span>line[line.len() - <span class="number">1</span>] == newline_char {
                            <span class="kw">return </span><span class="prelude-val">Ok</span>(<span class="bool-val">true</span>);
                        }
                        <span class="kw">break</span>;
                    }
                }
            }
        }

        out.write_all(<span class="kw-2">&amp;</span>[newline_char])<span class="question-mark">?</span>;
        <span class="prelude-val">Ok</span>(<span class="bool-val">true</span>)
    });

    <span class="kw">if let </span><span class="prelude-val">Err</span>(e) = result {
        <span class="kw">return </span><span class="prelude-val">Err</span>(USimpleError::new(<span class="number">1</span>, e.to_string()));
    }

    <span class="prelude-val">Ok</span>(())
}

<span class="kw">fn </span>cut_fields&lt;R: Read&gt;(reader: R, ranges: <span class="kw-2">&amp;</span>[Range], opts: <span class="kw-2">&amp;</span>FieldOptions) -&gt; UResult&lt;()&gt; {
    <span class="kw">let </span>newline_char = <span class="kw">if </span>opts.zero_terminated { <span class="string">b&#39;\0&#39; </span>} <span class="kw">else </span>{ <span class="string">b&#39;\n&#39; </span>};
    <span class="kw">match </span>opts.delimiter {
        Delimiter::Whitespace =&gt; cut_fields_whitespace(
            reader,
            ranges,
            opts.only_delimited,
            newline_char,
            opts.out_delimiter.as_deref().unwrap_or(<span class="string">&quot;\t&quot;</span>),
        ),
        Delimiter::String(<span class="kw-2">ref </span>delimiter) =&gt; {
            <span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="kw-2">ref </span>o_delim) = opts.out_delimiter {
                <span class="kw">return </span>cut_fields_delimiter(
                    reader,
                    ranges,
                    delimiter,
                    opts.only_delimited,
                    newline_char,
                    o_delim,
                );
            }

            <span class="kw">let </span><span class="kw-2">mut </span>buf_in = BufReader::new(reader);
            <span class="kw">let </span><span class="kw-2">mut </span>out = stdout_writer();
            <span class="kw">let </span>delim_len = delimiter.len();

            <span class="kw">let </span>result = buf_in.for_byte_record_with_terminator(newline_char, |line| {
                <span class="kw">let </span><span class="kw-2">mut </span>fields_pos = <span class="number">1</span>;
                <span class="kw">let </span><span class="kw-2">mut </span>low_idx = <span class="number">0</span>;
                <span class="kw">let </span><span class="kw-2">mut </span>delim_search = Searcher::new(line, delimiter.as_bytes()).peekable();
                <span class="kw">let </span><span class="kw-2">mut </span>print_delim = <span class="bool-val">false</span>;

                <span class="kw">if </span>delim_search.peek().is_none() {
                    <span class="kw">if </span>!opts.only_delimited {
                        out.write_all(line)<span class="question-mark">?</span>;
                        <span class="kw">if </span>line[line.len() - <span class="number">1</span>] != newline_char {
                            out.write_all(<span class="kw-2">&amp;</span>[newline_char])<span class="question-mark">?</span>;
                        }
                    }

                    <span class="kw">return </span><span class="prelude-val">Ok</span>(<span class="bool-val">true</span>);
                }

                <span class="kw">for </span><span class="kw-2">&amp;</span>Range { low, high } <span class="kw">in </span>ranges {
                    <span class="kw">if </span>low - fields_pos &gt; <span class="number">0 </span>{
                        <span class="kw">if let </span><span class="prelude-val">Some</span>(delim_pos) = delim_search.nth(low - fields_pos - <span class="number">1</span>) {
                            low_idx = <span class="kw">if </span>print_delim {
                                delim_pos
                            } <span class="kw">else </span>{
                                delim_pos + delim_len
                            }
                        } <span class="kw">else </span>{
                            <span class="kw">break</span>;
                        }
                    }

                    <span class="kw">match </span>delim_search.nth(high - low) {
                        <span class="prelude-val">Some</span>(high_idx) =&gt; {
                            <span class="kw">let </span>segment = <span class="kw-2">&amp;</span>line[low_idx..high_idx];

                            out.write_all(segment)<span class="question-mark">?</span>;

                            print_delim = <span class="bool-val">true</span>;
                            low_idx = high_idx;
                            fields_pos = high + <span class="number">1</span>;
                        }
                        <span class="prelude-val">None </span>=&gt; {
                            <span class="kw">let </span>segment = <span class="kw-2">&amp;</span>line[low_idx..line.len()];

                            out.write_all(segment)<span class="question-mark">?</span>;

                            <span class="kw">if </span>line[line.len() - <span class="number">1</span>] == newline_char {
                                <span class="kw">return </span><span class="prelude-val">Ok</span>(<span class="bool-val">true</span>);
                            }
                            <span class="kw">break</span>;
                        }
                    }
                }
                out.write_all(<span class="kw-2">&amp;</span>[newline_char])<span class="question-mark">?</span>;
                <span class="prelude-val">Ok</span>(<span class="bool-val">true</span>)
            });

            <span class="kw">if let </span><span class="prelude-val">Err</span>(e) = result {
                <span class="kw">return </span><span class="prelude-val">Err</span>(USimpleError::new(<span class="number">1</span>, e.to_string()));
            }

            <span class="prelude-val">Ok</span>(())
        }
    }
}

<span class="kw">fn </span>cut_files(<span class="kw-2">mut </span>filenames: Vec&lt;String&gt;, mode: <span class="kw-2">&amp;</span>Mode) {
    <span class="kw">let </span><span class="kw-2">mut </span>stdin_read = <span class="bool-val">false</span>;

    <span class="kw">if </span>filenames.is_empty() {
        filenames.push(<span class="string">&quot;-&quot;</span>.to_owned());
    }

    <span class="kw">for </span>filename <span class="kw">in </span><span class="kw-2">&amp;</span>filenames {
        <span class="kw">if </span>filename == <span class="string">&quot;-&quot; </span>{
            <span class="kw">if </span>stdin_read {
                <span class="kw">continue</span>;
            }

            <span class="macro">show_if_err!</span>(<span class="kw">match </span>mode {
                Mode::Bytes(<span class="kw-2">ref </span>ranges, <span class="kw-2">ref </span>opts) =&gt; cut_bytes(stdin(), ranges, opts),
                Mode::Characters(<span class="kw-2">ref </span>ranges, <span class="kw-2">ref </span>opts) =&gt; cut_bytes(stdin(), ranges, opts),
                Mode::Fields(<span class="kw-2">ref </span>ranges, <span class="kw-2">ref </span>opts) =&gt; cut_fields(stdin(), ranges, opts),
            });

            stdin_read = <span class="bool-val">true</span>;
        } <span class="kw">else </span>{
            <span class="kw">let </span>path = Path::new(<span class="kw-2">&amp;</span>filename[..]);

            <span class="kw">if </span>path.is_dir() {
                <span class="macro">show_error!</span>(<span class="string">&quot;{}: Is a directory&quot;</span>, filename.maybe_quote());
                <span class="kw">continue</span>;
            }

            <span class="macro">show_if_err!</span>(File::open(path)
                .map_err_context(|| filename.maybe_quote().to_string())
                .and_then(|file| {
                    <span class="kw">match </span><span class="kw-2">&amp;</span>mode {
                        Mode::Bytes(ranges, opts) | Mode::Characters(ranges, opts) =&gt; {
                            cut_bytes(file, ranges, opts)
                        }
                        Mode::Fields(ranges, opts) =&gt; cut_fields(file, ranges, opts),
                    }
                }));
        }
    }
}

<span class="kw">mod </span>options {
    <span class="kw">pub const </span>BYTES: <span class="kw-2">&amp;</span>str = <span class="string">&quot;bytes&quot;</span>;
    <span class="kw">pub const </span>CHARACTERS: <span class="kw-2">&amp;</span>str = <span class="string">&quot;characters&quot;</span>;
    <span class="kw">pub const </span>DELIMITER: <span class="kw-2">&amp;</span>str = <span class="string">&quot;delimiter&quot;</span>;
    <span class="kw">pub const </span>FIELDS: <span class="kw-2">&amp;</span>str = <span class="string">&quot;fields&quot;</span>;
    <span class="kw">pub const </span>ZERO_TERMINATED: <span class="kw-2">&amp;</span>str = <span class="string">&quot;zero-terminated&quot;</span>;
    <span class="kw">pub const </span>ONLY_DELIMITED: <span class="kw-2">&amp;</span>str = <span class="string">&quot;only-delimited&quot;</span>;
    <span class="kw">pub const </span>OUTPUT_DELIMITER: <span class="kw-2">&amp;</span>str = <span class="string">&quot;output-delimiter&quot;</span>;
    <span class="kw">pub const </span>WHITESPACE_DELIMITED: <span class="kw-2">&amp;</span>str = <span class="string">&quot;whitespace-delimited&quot;</span>;
    <span class="kw">pub const </span>COMPLEMENT: <span class="kw-2">&amp;</span>str = <span class="string">&quot;complement&quot;</span>;
    <span class="kw">pub const </span>FILE: <span class="kw-2">&amp;</span>str = <span class="string">&quot;file&quot;</span>;
}

<span class="attribute">#[uucore::main]
</span><span class="kw">pub fn </span>uumain(args: <span class="kw">impl </span>uucore::Args) -&gt; UResult&lt;()&gt; {
    <span class="kw">let </span>args = args.collect_ignore();

    <span class="kw">let </span>delimiter_is_equal = args.contains(<span class="kw-2">&amp;</span><span class="string">&quot;-d=&quot;</span>.to_string()); <span class="comment">// special case
    </span><span class="kw">let </span>matches = uu_app().try_get_matches_from(args)<span class="question-mark">?</span>;

    <span class="kw">let </span>complement = matches.get_flag(options::COMPLEMENT);

    <span class="kw">let </span>mode_parse = <span class="kw">match </span>(
        matches.get_one::&lt;String&gt;(options::BYTES),
        matches.get_one::&lt;String&gt;(options::CHARACTERS),
        matches.get_one::&lt;String&gt;(options::FIELDS),
    ) {
        (<span class="prelude-val">Some</span>(byte_ranges), <span class="prelude-val">None</span>, <span class="prelude-val">None</span>) =&gt; list_to_ranges(byte_ranges, complement).map(|ranges| {
            Mode::Bytes(
                ranges,
                Options {
                    out_delim: <span class="prelude-val">Some</span>(
                        matches
                            .get_one::&lt;String&gt;(options::OUTPUT_DELIMITER)
                            .map(|s| s.as_str())
                            .unwrap_or_default()
                            .to_owned(),
                    ),
                    zero_terminated: matches.get_flag(options::ZERO_TERMINATED),
                },
            )
        }),
        (<span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(char_ranges), <span class="prelude-val">None</span>) =&gt; list_to_ranges(char_ranges, complement).map(|ranges| {
            Mode::Characters(
                ranges,
                Options {
                    out_delim: <span class="prelude-val">Some</span>(
                        matches
                            .get_one::&lt;String&gt;(options::OUTPUT_DELIMITER)
                            .map(|s| s.as_str())
                            .unwrap_or_default()
                            .to_owned(),
                    ),
                    zero_terminated: matches.get_flag(options::ZERO_TERMINATED),
                },
            )
        }),
        (<span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(field_ranges)) =&gt; {
            list_to_ranges(field_ranges, complement).and_then(|ranges| {
                <span class="kw">let </span>out_delim = <span class="kw">match </span>matches.get_one::&lt;String&gt;(options::OUTPUT_DELIMITER) {
                    <span class="prelude-val">Some</span>(s) =&gt; {
                        <span class="kw">if </span>s.is_empty() {
                            <span class="prelude-val">Some</span>(<span class="string">&quot;\0&quot;</span>.to_owned())
                        } <span class="kw">else </span>{
                            <span class="prelude-val">Some</span>(s.to_owned())
                        }
                    }
                    <span class="prelude-val">None </span>=&gt; <span class="prelude-val">None</span>,
                };

                <span class="kw">let </span>only_delimited = matches.get_flag(options::ONLY_DELIMITED);
                <span class="kw">let </span>whitespace_delimited = matches.get_flag(options::WHITESPACE_DELIMITED);
                <span class="kw">let </span>zero_terminated = matches.get_flag(options::ZERO_TERMINATED);

                <span class="kw">match </span>matches.get_one::&lt;String&gt;(options::DELIMITER).map(|s| s.as_str()) {
                    <span class="prelude-val">Some</span>(<span class="kw">_</span>) <span class="kw">if </span>whitespace_delimited =&gt; {
                            <span class="prelude-val">Err</span>(<span class="string">&quot;invalid input: Only one of --delimiter (-d) or -w option can be specified&quot;</span>.into())
                        }
                    <span class="prelude-val">Some</span>(<span class="kw-2">mut </span>delim) =&gt; {
                        <span class="comment">// GNU&#39;s `cut` supports `-d=` to set the delimiter to `=`.
                        // Clap parsing is limited in this situation, see:
                        // https://github.com/uutils/coreutils/issues/2424#issuecomment-863825242
                        </span><span class="kw">if </span>delimiter_is_equal {
                            delim = <span class="string">&quot;=&quot;</span>;
                        } <span class="kw">else if </span>delim == <span class="string">&quot;&#39;&#39;&quot; </span>{
                            <span class="comment">// treat `&#39;&#39;` as empty delimiter
                            </span>delim = <span class="string">&quot;&quot;</span>;
                        }
                        <span class="kw">if </span>delim.chars().count() &gt; <span class="number">1 </span>{
                            <span class="prelude-val">Err</span>(<span class="string">&quot;invalid input: The &#39;--delimiter&#39; (&#39;-d&#39;) option expects empty or 1 character long, but was provided a value 2 characters or longer&quot;</span>.into())
                        } <span class="kw">else </span>{
                            <span class="kw">let </span>delim = <span class="kw">if </span>delim.is_empty() {
                                <span class="string">&quot;\0&quot;</span>.to_owned()
                            } <span class="kw">else </span>{
                                delim.to_owned()
                            };

                            <span class="prelude-val">Ok</span>(Mode::Fields(
                                ranges,
                                FieldOptions {
                                    delimiter: Delimiter::String(delim),
                                    out_delimiter: out_delim,
                                    only_delimited,
                                    zero_terminated,
                                },
                            ))
                        }
                    }
                    <span class="prelude-val">None </span>=&gt; <span class="prelude-val">Ok</span>(Mode::Fields(
                        ranges,
                        FieldOptions {
                            delimiter: <span class="kw">match </span>whitespace_delimited {
                                <span class="bool-val">true </span>=&gt; Delimiter::Whitespace,
                                <span class="bool-val">false </span>=&gt; Delimiter::String(<span class="string">&quot;\t&quot;</span>.to_owned()),
                            },
                            out_delimiter: out_delim,
                            only_delimited,
                            zero_terminated,
                        },
                    )),
                }
            })
        }
        (<span class="kw-2">ref </span>b, <span class="kw-2">ref </span>c, <span class="kw-2">ref </span>f) <span class="kw">if </span>b.is_some() || c.is_some() || f.is_some() =&gt; <span class="prelude-val">Err</span>(
            <span class="string">&quot;invalid usage: expects no more than one of --fields (-f), --chars (-c) or --bytes (-b)&quot;</span>.into()
        ),
        <span class="kw">_ </span>=&gt; <span class="prelude-val">Err</span>(<span class="string">&quot;invalid usage: expects one of --fields (-f), --chars (-c) or --bytes (-b)&quot;</span>.into()),
    };

    <span class="kw">let </span>mode_parse = <span class="kw">match </span>mode_parse {
        <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; mode_parse,
        <span class="prelude-val">Ok</span>(mode) =&gt; <span class="kw">match </span>mode {
            Mode::Bytes(<span class="kw">_</span>, <span class="kw">_</span>) | Mode::Characters(<span class="kw">_</span>, <span class="kw">_</span>)
                <span class="kw">if </span>matches.contains_id(options::DELIMITER) =&gt;
            {
                <span class="prelude-val">Err</span>(<span class="string">&quot;invalid input: The &#39;--delimiter&#39; (&#39;-d&#39;) option only usable if printing a sequence of fields&quot;</span>.into())
            }
            Mode::Bytes(<span class="kw">_</span>, <span class="kw">_</span>) | Mode::Characters(<span class="kw">_</span>, <span class="kw">_</span>)
                <span class="kw">if </span>matches.get_flag(options::WHITESPACE_DELIMITED) =&gt;
            {
                <span class="prelude-val">Err</span>(<span class="string">&quot;invalid input: The &#39;-w&#39; option only usable if printing a sequence of fields&quot;</span>.into())
            }
            Mode::Bytes(<span class="kw">_</span>, <span class="kw">_</span>) | Mode::Characters(<span class="kw">_</span>, <span class="kw">_</span>)
                <span class="kw">if </span>matches.get_flag(options::ONLY_DELIMITED) =&gt;
            {
                <span class="prelude-val">Err</span>(<span class="string">&quot;invalid input: The &#39;--only-delimited&#39; (&#39;-s&#39;) option only usable if printing a sequence of fields&quot;</span>.into())
            }
            <span class="kw">_ </span>=&gt; <span class="prelude-val">Ok</span>(mode),
        },
    };

    <span class="kw">let </span>files: Vec&lt;String&gt; = matches
        .get_many::&lt;String&gt;(options::FILE)
        .unwrap_or_default()
        .map(|s| s.to_owned())
        .collect();

    <span class="kw">match </span>mode_parse {
        <span class="prelude-val">Ok</span>(mode) =&gt; {
            cut_files(files, <span class="kw-2">&amp;</span>mode);
            <span class="prelude-val">Ok</span>(())
        }
        <span class="prelude-val">Err</span>(e) =&gt; <span class="prelude-val">Err</span>(USimpleError::new(<span class="number">1</span>, e)),
    }
}

<span class="kw">pub fn </span>uu_app() -&gt; Command {
    Command::new(uucore::util_name())
        .version(<span class="macro">crate_version!</span>())
        .override_usage(format_usage(USAGE))
        .about(ABOUT)
        .after_help(LONG_HELP)
        .infer_long_args(<span class="bool-val">true</span>)
        .arg(
            Arg::new(options::BYTES)
                .short(<span class="string">&#39;b&#39;</span>)
                .long(options::BYTES)
                .help(<span class="string">&quot;filter byte columns from the input source&quot;</span>)
                .allow_hyphen_values(<span class="bool-val">true</span>)
                .value_name(<span class="string">&quot;LIST&quot;</span>),
        )
        .arg(
            Arg::new(options::CHARACTERS)
                .short(<span class="string">&#39;c&#39;</span>)
                .long(options::CHARACTERS)
                .help(<span class="string">&quot;alias for character mode&quot;</span>)
                .allow_hyphen_values(<span class="bool-val">true</span>)
                .value_name(<span class="string">&quot;LIST&quot;</span>),
        )
        .arg(
            Arg::new(options::DELIMITER)
                .short(<span class="string">&#39;d&#39;</span>)
                .long(options::DELIMITER)
                .help(<span class="string">&quot;specify the delimiter character that separates fields in the input source. Defaults to Tab.&quot;</span>)
                .value_name(<span class="string">&quot;DELIM&quot;</span>),
        )
        .arg(
            Arg::new(options::WHITESPACE_DELIMITED)
                .short(<span class="string">&#39;w&#39;</span>)
                .help(<span class="string">&quot;Use any number of whitespace (Space, Tab) to separate fields in the input source (FreeBSD extension).&quot;</span>)
                .value_name(<span class="string">&quot;WHITESPACE&quot;</span>)
                .action(ArgAction::SetTrue),
        )
        .arg(
            Arg::new(options::FIELDS)
                .short(<span class="string">&#39;f&#39;</span>)
                .long(options::FIELDS)
                .help(<span class="string">&quot;filter field columns from the input source&quot;</span>)
                .allow_hyphen_values(<span class="bool-val">true</span>)
                .value_name(<span class="string">&quot;LIST&quot;</span>),
        )
        .arg(
            Arg::new(options::COMPLEMENT)
                .long(options::COMPLEMENT)
                .help(<span class="string">&quot;invert the filter - instead of displaying only the filtered columns, display all but those columns&quot;</span>)
                .action(ArgAction::SetTrue),
        )
        .arg(
            Arg::new(options::ONLY_DELIMITED)
                .short(<span class="string">&#39;s&#39;</span>)
                .long(options::ONLY_DELIMITED)
                .help(<span class="string">&quot;in field mode, only print lines which contain the delimiter&quot;</span>)
                .action(ArgAction::SetTrue),
        )
        .arg(
            Arg::new(options::ZERO_TERMINATED)
                .short(<span class="string">&#39;z&#39;</span>)
                .long(options::ZERO_TERMINATED)
                .help(<span class="string">&quot;instead of filtering columns based on line, filter columns based on \\0 (NULL character)&quot;</span>)
                .action(ArgAction::SetTrue),
        )
        .arg(
            Arg::new(options::OUTPUT_DELIMITER)
                .long(options::OUTPUT_DELIMITER)
                .help(<span class="string">&quot;in field mode, replace the delimiter in output lines with this option&#39;s argument&quot;</span>)
                .value_name(<span class="string">&quot;NEW_DELIM&quot;</span>),
        )
        .arg(
            Arg::new(options::FILE)
            .hide(<span class="bool-val">true</span>)
            .action(ArgAction::Append)
            .value_hint(clap::ValueHint::FilePath)
        )
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="uu_cut" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.1 (90743e729 2023-01-10)" ></div></body></html>