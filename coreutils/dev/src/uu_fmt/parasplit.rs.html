<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src/uu/fmt/src/parasplit.rs`."><title>parasplit.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-f3501f0f5ae15dfb.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="uu_fmt" data-themes="" data-resource-suffix="" data-rustdoc-version="1.71.1 (eb26296b5 2023-08-03)" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../../static.files/source-script-11255107d0a65077.js"></script><script defer src="../../source-files.js"></script><script defer src="../../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><main><nav class="sub"><a class="sub-logo-container" href="../../uu_fmt/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers"><a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
<a href="#3" id="3">3</a>
<a href="#4" id="4">4</a>
<a href="#5" id="5">5</a>
<a href="#6" id="6">6</a>
<a href="#7" id="7">7</a>
<a href="#8" id="8">8</a>
<a href="#9" id="9">9</a>
<a href="#10" id="10">10</a>
<a href="#11" id="11">11</a>
<a href="#12" id="12">12</a>
<a href="#13" id="13">13</a>
<a href="#14" id="14">14</a>
<a href="#15" id="15">15</a>
<a href="#16" id="16">16</a>
<a href="#17" id="17">17</a>
<a href="#18" id="18">18</a>
<a href="#19" id="19">19</a>
<a href="#20" id="20">20</a>
<a href="#21" id="21">21</a>
<a href="#22" id="22">22</a>
<a href="#23" id="23">23</a>
<a href="#24" id="24">24</a>
<a href="#25" id="25">25</a>
<a href="#26" id="26">26</a>
<a href="#27" id="27">27</a>
<a href="#28" id="28">28</a>
<a href="#29" id="29">29</a>
<a href="#30" id="30">30</a>
<a href="#31" id="31">31</a>
<a href="#32" id="32">32</a>
<a href="#33" id="33">33</a>
<a href="#34" id="34">34</a>
<a href="#35" id="35">35</a>
<a href="#36" id="36">36</a>
<a href="#37" id="37">37</a>
<a href="#38" id="38">38</a>
<a href="#39" id="39">39</a>
<a href="#40" id="40">40</a>
<a href="#41" id="41">41</a>
<a href="#42" id="42">42</a>
<a href="#43" id="43">43</a>
<a href="#44" id="44">44</a>
<a href="#45" id="45">45</a>
<a href="#46" id="46">46</a>
<a href="#47" id="47">47</a>
<a href="#48" id="48">48</a>
<a href="#49" id="49">49</a>
<a href="#50" id="50">50</a>
<a href="#51" id="51">51</a>
<a href="#52" id="52">52</a>
<a href="#53" id="53">53</a>
<a href="#54" id="54">54</a>
<a href="#55" id="55">55</a>
<a href="#56" id="56">56</a>
<a href="#57" id="57">57</a>
<a href="#58" id="58">58</a>
<a href="#59" id="59">59</a>
<a href="#60" id="60">60</a>
<a href="#61" id="61">61</a>
<a href="#62" id="62">62</a>
<a href="#63" id="63">63</a>
<a href="#64" id="64">64</a>
<a href="#65" id="65">65</a>
<a href="#66" id="66">66</a>
<a href="#67" id="67">67</a>
<a href="#68" id="68">68</a>
<a href="#69" id="69">69</a>
<a href="#70" id="70">70</a>
<a href="#71" id="71">71</a>
<a href="#72" id="72">72</a>
<a href="#73" id="73">73</a>
<a href="#74" id="74">74</a>
<a href="#75" id="75">75</a>
<a href="#76" id="76">76</a>
<a href="#77" id="77">77</a>
<a href="#78" id="78">78</a>
<a href="#79" id="79">79</a>
<a href="#80" id="80">80</a>
<a href="#81" id="81">81</a>
<a href="#82" id="82">82</a>
<a href="#83" id="83">83</a>
<a href="#84" id="84">84</a>
<a href="#85" id="85">85</a>
<a href="#86" id="86">86</a>
<a href="#87" id="87">87</a>
<a href="#88" id="88">88</a>
<a href="#89" id="89">89</a>
<a href="#90" id="90">90</a>
<a href="#91" id="91">91</a>
<a href="#92" id="92">92</a>
<a href="#93" id="93">93</a>
<a href="#94" id="94">94</a>
<a href="#95" id="95">95</a>
<a href="#96" id="96">96</a>
<a href="#97" id="97">97</a>
<a href="#98" id="98">98</a>
<a href="#99" id="99">99</a>
<a href="#100" id="100">100</a>
<a href="#101" id="101">101</a>
<a href="#102" id="102">102</a>
<a href="#103" id="103">103</a>
<a href="#104" id="104">104</a>
<a href="#105" id="105">105</a>
<a href="#106" id="106">106</a>
<a href="#107" id="107">107</a>
<a href="#108" id="108">108</a>
<a href="#109" id="109">109</a>
<a href="#110" id="110">110</a>
<a href="#111" id="111">111</a>
<a href="#112" id="112">112</a>
<a href="#113" id="113">113</a>
<a href="#114" id="114">114</a>
<a href="#115" id="115">115</a>
<a href="#116" id="116">116</a>
<a href="#117" id="117">117</a>
<a href="#118" id="118">118</a>
<a href="#119" id="119">119</a>
<a href="#120" id="120">120</a>
<a href="#121" id="121">121</a>
<a href="#122" id="122">122</a>
<a href="#123" id="123">123</a>
<a href="#124" id="124">124</a>
<a href="#125" id="125">125</a>
<a href="#126" id="126">126</a>
<a href="#127" id="127">127</a>
<a href="#128" id="128">128</a>
<a href="#129" id="129">129</a>
<a href="#130" id="130">130</a>
<a href="#131" id="131">131</a>
<a href="#132" id="132">132</a>
<a href="#133" id="133">133</a>
<a href="#134" id="134">134</a>
<a href="#135" id="135">135</a>
<a href="#136" id="136">136</a>
<a href="#137" id="137">137</a>
<a href="#138" id="138">138</a>
<a href="#139" id="139">139</a>
<a href="#140" id="140">140</a>
<a href="#141" id="141">141</a>
<a href="#142" id="142">142</a>
<a href="#143" id="143">143</a>
<a href="#144" id="144">144</a>
<a href="#145" id="145">145</a>
<a href="#146" id="146">146</a>
<a href="#147" id="147">147</a>
<a href="#148" id="148">148</a>
<a href="#149" id="149">149</a>
<a href="#150" id="150">150</a>
<a href="#151" id="151">151</a>
<a href="#152" id="152">152</a>
<a href="#153" id="153">153</a>
<a href="#154" id="154">154</a>
<a href="#155" id="155">155</a>
<a href="#156" id="156">156</a>
<a href="#157" id="157">157</a>
<a href="#158" id="158">158</a>
<a href="#159" id="159">159</a>
<a href="#160" id="160">160</a>
<a href="#161" id="161">161</a>
<a href="#162" id="162">162</a>
<a href="#163" id="163">163</a>
<a href="#164" id="164">164</a>
<a href="#165" id="165">165</a>
<a href="#166" id="166">166</a>
<a href="#167" id="167">167</a>
<a href="#168" id="168">168</a>
<a href="#169" id="169">169</a>
<a href="#170" id="170">170</a>
<a href="#171" id="171">171</a>
<a href="#172" id="172">172</a>
<a href="#173" id="173">173</a>
<a href="#174" id="174">174</a>
<a href="#175" id="175">175</a>
<a href="#176" id="176">176</a>
<a href="#177" id="177">177</a>
<a href="#178" id="178">178</a>
<a href="#179" id="179">179</a>
<a href="#180" id="180">180</a>
<a href="#181" id="181">181</a>
<a href="#182" id="182">182</a>
<a href="#183" id="183">183</a>
<a href="#184" id="184">184</a>
<a href="#185" id="185">185</a>
<a href="#186" id="186">186</a>
<a href="#187" id="187">187</a>
<a href="#188" id="188">188</a>
<a href="#189" id="189">189</a>
<a href="#190" id="190">190</a>
<a href="#191" id="191">191</a>
<a href="#192" id="192">192</a>
<a href="#193" id="193">193</a>
<a href="#194" id="194">194</a>
<a href="#195" id="195">195</a>
<a href="#196" id="196">196</a>
<a href="#197" id="197">197</a>
<a href="#198" id="198">198</a>
<a href="#199" id="199">199</a>
<a href="#200" id="200">200</a>
<a href="#201" id="201">201</a>
<a href="#202" id="202">202</a>
<a href="#203" id="203">203</a>
<a href="#204" id="204">204</a>
<a href="#205" id="205">205</a>
<a href="#206" id="206">206</a>
<a href="#207" id="207">207</a>
<a href="#208" id="208">208</a>
<a href="#209" id="209">209</a>
<a href="#210" id="210">210</a>
<a href="#211" id="211">211</a>
<a href="#212" id="212">212</a>
<a href="#213" id="213">213</a>
<a href="#214" id="214">214</a>
<a href="#215" id="215">215</a>
<a href="#216" id="216">216</a>
<a href="#217" id="217">217</a>
<a href="#218" id="218">218</a>
<a href="#219" id="219">219</a>
<a href="#220" id="220">220</a>
<a href="#221" id="221">221</a>
<a href="#222" id="222">222</a>
<a href="#223" id="223">223</a>
<a href="#224" id="224">224</a>
<a href="#225" id="225">225</a>
<a href="#226" id="226">226</a>
<a href="#227" id="227">227</a>
<a href="#228" id="228">228</a>
<a href="#229" id="229">229</a>
<a href="#230" id="230">230</a>
<a href="#231" id="231">231</a>
<a href="#232" id="232">232</a>
<a href="#233" id="233">233</a>
<a href="#234" id="234">234</a>
<a href="#235" id="235">235</a>
<a href="#236" id="236">236</a>
<a href="#237" id="237">237</a>
<a href="#238" id="238">238</a>
<a href="#239" id="239">239</a>
<a href="#240" id="240">240</a>
<a href="#241" id="241">241</a>
<a href="#242" id="242">242</a>
<a href="#243" id="243">243</a>
<a href="#244" id="244">244</a>
<a href="#245" id="245">245</a>
<a href="#246" id="246">246</a>
<a href="#247" id="247">247</a>
<a href="#248" id="248">248</a>
<a href="#249" id="249">249</a>
<a href="#250" id="250">250</a>
<a href="#251" id="251">251</a>
<a href="#252" id="252">252</a>
<a href="#253" id="253">253</a>
<a href="#254" id="254">254</a>
<a href="#255" id="255">255</a>
<a href="#256" id="256">256</a>
<a href="#257" id="257">257</a>
<a href="#258" id="258">258</a>
<a href="#259" id="259">259</a>
<a href="#260" id="260">260</a>
<a href="#261" id="261">261</a>
<a href="#262" id="262">262</a>
<a href="#263" id="263">263</a>
<a href="#264" id="264">264</a>
<a href="#265" id="265">265</a>
<a href="#266" id="266">266</a>
<a href="#267" id="267">267</a>
<a href="#268" id="268">268</a>
<a href="#269" id="269">269</a>
<a href="#270" id="270">270</a>
<a href="#271" id="271">271</a>
<a href="#272" id="272">272</a>
<a href="#273" id="273">273</a>
<a href="#274" id="274">274</a>
<a href="#275" id="275">275</a>
<a href="#276" id="276">276</a>
<a href="#277" id="277">277</a>
<a href="#278" id="278">278</a>
<a href="#279" id="279">279</a>
<a href="#280" id="280">280</a>
<a href="#281" id="281">281</a>
<a href="#282" id="282">282</a>
<a href="#283" id="283">283</a>
<a href="#284" id="284">284</a>
<a href="#285" id="285">285</a>
<a href="#286" id="286">286</a>
<a href="#287" id="287">287</a>
<a href="#288" id="288">288</a>
<a href="#289" id="289">289</a>
<a href="#290" id="290">290</a>
<a href="#291" id="291">291</a>
<a href="#292" id="292">292</a>
<a href="#293" id="293">293</a>
<a href="#294" id="294">294</a>
<a href="#295" id="295">295</a>
<a href="#296" id="296">296</a>
<a href="#297" id="297">297</a>
<a href="#298" id="298">298</a>
<a href="#299" id="299">299</a>
<a href="#300" id="300">300</a>
<a href="#301" id="301">301</a>
<a href="#302" id="302">302</a>
<a href="#303" id="303">303</a>
<a href="#304" id="304">304</a>
<a href="#305" id="305">305</a>
<a href="#306" id="306">306</a>
<a href="#307" id="307">307</a>
<a href="#308" id="308">308</a>
<a href="#309" id="309">309</a>
<a href="#310" id="310">310</a>
<a href="#311" id="311">311</a>
<a href="#312" id="312">312</a>
<a href="#313" id="313">313</a>
<a href="#314" id="314">314</a>
<a href="#315" id="315">315</a>
<a href="#316" id="316">316</a>
<a href="#317" id="317">317</a>
<a href="#318" id="318">318</a>
<a href="#319" id="319">319</a>
<a href="#320" id="320">320</a>
<a href="#321" id="321">321</a>
<a href="#322" id="322">322</a>
<a href="#323" id="323">323</a>
<a href="#324" id="324">324</a>
<a href="#325" id="325">325</a>
<a href="#326" id="326">326</a>
<a href="#327" id="327">327</a>
<a href="#328" id="328">328</a>
<a href="#329" id="329">329</a>
<a href="#330" id="330">330</a>
<a href="#331" id="331">331</a>
<a href="#332" id="332">332</a>
<a href="#333" id="333">333</a>
<a href="#334" id="334">334</a>
<a href="#335" id="335">335</a>
<a href="#336" id="336">336</a>
<a href="#337" id="337">337</a>
<a href="#338" id="338">338</a>
<a href="#339" id="339">339</a>
<a href="#340" id="340">340</a>
<a href="#341" id="341">341</a>
<a href="#342" id="342">342</a>
<a href="#343" id="343">343</a>
<a href="#344" id="344">344</a>
<a href="#345" id="345">345</a>
<a href="#346" id="346">346</a>
<a href="#347" id="347">347</a>
<a href="#348" id="348">348</a>
<a href="#349" id="349">349</a>
<a href="#350" id="350">350</a>
<a href="#351" id="351">351</a>
<a href="#352" id="352">352</a>
<a href="#353" id="353">353</a>
<a href="#354" id="354">354</a>
<a href="#355" id="355">355</a>
<a href="#356" id="356">356</a>
<a href="#357" id="357">357</a>
<a href="#358" id="358">358</a>
<a href="#359" id="359">359</a>
<a href="#360" id="360">360</a>
<a href="#361" id="361">361</a>
<a href="#362" id="362">362</a>
<a href="#363" id="363">363</a>
<a href="#364" id="364">364</a>
<a href="#365" id="365">365</a>
<a href="#366" id="366">366</a>
<a href="#367" id="367">367</a>
<a href="#368" id="368">368</a>
<a href="#369" id="369">369</a>
<a href="#370" id="370">370</a>
<a href="#371" id="371">371</a>
<a href="#372" id="372">372</a>
<a href="#373" id="373">373</a>
<a href="#374" id="374">374</a>
<a href="#375" id="375">375</a>
<a href="#376" id="376">376</a>
<a href="#377" id="377">377</a>
<a href="#378" id="378">378</a>
<a href="#379" id="379">379</a>
<a href="#380" id="380">380</a>
<a href="#381" id="381">381</a>
<a href="#382" id="382">382</a>
<a href="#383" id="383">383</a>
<a href="#384" id="384">384</a>
<a href="#385" id="385">385</a>
<a href="#386" id="386">386</a>
<a href="#387" id="387">387</a>
<a href="#388" id="388">388</a>
<a href="#389" id="389">389</a>
<a href="#390" id="390">390</a>
<a href="#391" id="391">391</a>
<a href="#392" id="392">392</a>
<a href="#393" id="393">393</a>
<a href="#394" id="394">394</a>
<a href="#395" id="395">395</a>
<a href="#396" id="396">396</a>
<a href="#397" id="397">397</a>
<a href="#398" id="398">398</a>
<a href="#399" id="399">399</a>
<a href="#400" id="400">400</a>
<a href="#401" id="401">401</a>
<a href="#402" id="402">402</a>
<a href="#403" id="403">403</a>
<a href="#404" id="404">404</a>
<a href="#405" id="405">405</a>
<a href="#406" id="406">406</a>
<a href="#407" id="407">407</a>
<a href="#408" id="408">408</a>
<a href="#409" id="409">409</a>
<a href="#410" id="410">410</a>
<a href="#411" id="411">411</a>
<a href="#412" id="412">412</a>
<a href="#413" id="413">413</a>
<a href="#414" id="414">414</a>
<a href="#415" id="415">415</a>
<a href="#416" id="416">416</a>
<a href="#417" id="417">417</a>
<a href="#418" id="418">418</a>
<a href="#419" id="419">419</a>
<a href="#420" id="420">420</a>
<a href="#421" id="421">421</a>
<a href="#422" id="422">422</a>
<a href="#423" id="423">423</a>
<a href="#424" id="424">424</a>
<a href="#425" id="425">425</a>
<a href="#426" id="426">426</a>
<a href="#427" id="427">427</a>
<a href="#428" id="428">428</a>
<a href="#429" id="429">429</a>
<a href="#430" id="430">430</a>
<a href="#431" id="431">431</a>
<a href="#432" id="432">432</a>
<a href="#433" id="433">433</a>
<a href="#434" id="434">434</a>
<a href="#435" id="435">435</a>
<a href="#436" id="436">436</a>
<a href="#437" id="437">437</a>
<a href="#438" id="438">438</a>
<a href="#439" id="439">439</a>
<a href="#440" id="440">440</a>
<a href="#441" id="441">441</a>
<a href="#442" id="442">442</a>
<a href="#443" id="443">443</a>
<a href="#444" id="444">444</a>
<a href="#445" id="445">445</a>
<a href="#446" id="446">446</a>
<a href="#447" id="447">447</a>
<a href="#448" id="448">448</a>
<a href="#449" id="449">449</a>
<a href="#450" id="450">450</a>
<a href="#451" id="451">451</a>
<a href="#452" id="452">452</a>
<a href="#453" id="453">453</a>
<a href="#454" id="454">454</a>
<a href="#455" id="455">455</a>
<a href="#456" id="456">456</a>
<a href="#457" id="457">457</a>
<a href="#458" id="458">458</a>
<a href="#459" id="459">459</a>
<a href="#460" id="460">460</a>
<a href="#461" id="461">461</a>
<a href="#462" id="462">462</a>
<a href="#463" id="463">463</a>
<a href="#464" id="464">464</a>
<a href="#465" id="465">465</a>
<a href="#466" id="466">466</a>
<a href="#467" id="467">467</a>
<a href="#468" id="468">468</a>
<a href="#469" id="469">469</a>
<a href="#470" id="470">470</a>
<a href="#471" id="471">471</a>
<a href="#472" id="472">472</a>
<a href="#473" id="473">473</a>
<a href="#474" id="474">474</a>
<a href="#475" id="475">475</a>
<a href="#476" id="476">476</a>
<a href="#477" id="477">477</a>
<a href="#478" id="478">478</a>
<a href="#479" id="479">479</a>
<a href="#480" id="480">480</a>
<a href="#481" id="481">481</a>
<a href="#482" id="482">482</a>
<a href="#483" id="483">483</a>
<a href="#484" id="484">484</a>
<a href="#485" id="485">485</a>
<a href="#486" id="486">486</a>
<a href="#487" id="487">487</a>
<a href="#488" id="488">488</a>
<a href="#489" id="489">489</a>
<a href="#490" id="490">490</a>
<a href="#491" id="491">491</a>
<a href="#492" id="492">492</a>
<a href="#493" id="493">493</a>
<a href="#494" id="494">494</a>
<a href="#495" id="495">495</a>
<a href="#496" id="496">496</a>
<a href="#497" id="497">497</a>
<a href="#498" id="498">498</a>
<a href="#499" id="499">499</a>
<a href="#500" id="500">500</a>
<a href="#501" id="501">501</a>
<a href="#502" id="502">502</a>
<a href="#503" id="503">503</a>
<a href="#504" id="504">504</a>
<a href="#505" id="505">505</a>
<a href="#506" id="506">506</a>
<a href="#507" id="507">507</a>
<a href="#508" id="508">508</a>
<a href="#509" id="509">509</a>
<a href="#510" id="510">510</a>
<a href="#511" id="511">511</a>
<a href="#512" id="512">512</a>
<a href="#513" id="513">513</a>
<a href="#514" id="514">514</a>
<a href="#515" id="515">515</a>
<a href="#516" id="516">516</a>
<a href="#517" id="517">517</a>
<a href="#518" id="518">518</a>
<a href="#519" id="519">519</a>
<a href="#520" id="520">520</a>
<a href="#521" id="521">521</a>
<a href="#522" id="522">522</a>
<a href="#523" id="523">523</a>
<a href="#524" id="524">524</a>
<a href="#525" id="525">525</a>
<a href="#526" id="526">526</a>
<a href="#527" id="527">527</a>
<a href="#528" id="528">528</a>
<a href="#529" id="529">529</a>
<a href="#530" id="530">530</a>
<a href="#531" id="531">531</a>
<a href="#532" id="532">532</a>
<a href="#533" id="533">533</a>
<a href="#534" id="534">534</a>
<a href="#535" id="535">535</a>
<a href="#536" id="536">536</a>
<a href="#537" id="537">537</a>
<a href="#538" id="538">538</a>
<a href="#539" id="539">539</a>
<a href="#540" id="540">540</a>
<a href="#541" id="541">541</a>
<a href="#542" id="542">542</a>
<a href="#543" id="543">543</a>
<a href="#544" id="544">544</a>
<a href="#545" id="545">545</a>
<a href="#546" id="546">546</a>
<a href="#547" id="547">547</a>
<a href="#548" id="548">548</a>
<a href="#549" id="549">549</a>
<a href="#550" id="550">550</a>
<a href="#551" id="551">551</a>
<a href="#552" id="552">552</a>
<a href="#553" id="553">553</a>
<a href="#554" id="554">554</a>
<a href="#555" id="555">555</a>
<a href="#556" id="556">556</a>
<a href="#557" id="557">557</a>
<a href="#558" id="558">558</a>
<a href="#559" id="559">559</a>
<a href="#560" id="560">560</a>
<a href="#561" id="561">561</a>
<a href="#562" id="562">562</a>
<a href="#563" id="563">563</a>
<a href="#564" id="564">564</a>
<a href="#565" id="565">565</a>
<a href="#566" id="566">566</a>
<a href="#567" id="567">567</a>
<a href="#568" id="568">568</a>
<a href="#569" id="569">569</a>
<a href="#570" id="570">570</a>
<a href="#571" id="571">571</a>
<a href="#572" id="572">572</a>
<a href="#573" id="573">573</a>
<a href="#574" id="574">574</a>
<a href="#575" id="575">575</a>
<a href="#576" id="576">576</a>
<a href="#577" id="577">577</a>
<a href="#578" id="578">578</a>
<a href="#579" id="579">579</a>
<a href="#580" id="580">580</a>
<a href="#581" id="581">581</a>
<a href="#582" id="582">582</a>
<a href="#583" id="583">583</a>
<a href="#584" id="584">584</a>
<a href="#585" id="585">585</a>
<a href="#586" id="586">586</a>
<a href="#587" id="587">587</a>
<a href="#588" id="588">588</a>
<a href="#589" id="589">589</a>
<a href="#590" id="590">590</a>
<a href="#591" id="591">591</a>
<a href="#592" id="592">592</a>
<a href="#593" id="593">593</a>
<a href="#594" id="594">594</a>
<a href="#595" id="595">595</a>
<a href="#596" id="596">596</a>
<a href="#597" id="597">597</a>
<a href="#598" id="598">598</a>
<a href="#599" id="599">599</a>
<a href="#600" id="600">600</a>
<a href="#601" id="601">601</a>
<a href="#602" id="602">602</a>
<a href="#603" id="603">603</a>
<a href="#604" id="604">604</a>
<a href="#605" id="605">605</a>
<a href="#606" id="606">606</a>
<a href="#607" id="607">607</a>
<a href="#608" id="608">608</a>
<a href="#609" id="609">609</a>
<a href="#610" id="610">610</a>
<a href="#611" id="611">611</a>
<a href="#612" id="612">612</a>
<a href="#613" id="613">613</a>
<a href="#614" id="614">614</a>
<a href="#615" id="615">615</a>
<a href="#616" id="616">616</a>
<a href="#617" id="617">617</a>
<a href="#618" id="618">618</a>
<a href="#619" id="619">619</a>
<a href="#620" id="620">620</a>
<a href="#621" id="621">621</a>
<a href="#622" id="622">622</a>
<a href="#623" id="623">623</a>
<a href="#624" id="624">624</a>
<a href="#625" id="625">625</a>
<a href="#626" id="626">626</a>
<a href="#627" id="627">627</a>
<a href="#628" id="628">628</a>
</pre></div><pre class="rust"><code><span class="comment">//  * This file is part of `fmt` from the uutils coreutils package.
//  *
//  * (c) kwantam &lt;kwantam@gmail.com&gt;
//  *
//  * For the full copyright and license information, please view the LICENSE
//  * file that was distributed with this source code.

// spell-checker:ignore (ToDO) INFTY MULT PSKIP accum aftertab beforetab breakwords fmt&#39;s formatline linebreak linebreaking linebreaks linelen maxlength minlength nchars noformat noformatline ostream overlen parasplit pfxind plass pmatch poffset posn powf prefixindent punct signum slen sstart tabwidth tlen underlen winfo wlen wordlen wordsplits xanti xprefix

</span><span class="kw">use </span>std::io::{BufRead, Lines};
<span class="kw">use </span>std::iter::Peekable;
<span class="kw">use </span>std::slice::Iter;
<span class="kw">use </span>unicode_width::UnicodeWidthChar;

<span class="kw">use </span><span class="kw">crate</span>::FileOrStdReader;
<span class="kw">use </span><span class="kw">crate</span>::FmtOptions;

<span class="kw">fn </span>char_width(c: char) -&gt; usize {
    <span class="kw">if </span>(c <span class="kw">as </span>usize) &lt; <span class="number">0xA0 </span>{
        <span class="comment">// if it is ASCII, call it exactly 1 wide (including control chars)
        // calling control chars&#39; widths 1 is consistent with OpenBSD fmt
        </span><span class="number">1
    </span>} <span class="kw">else </span>{
        <span class="comment">// otherwise, get the unicode width
        // note that we shouldn&#39;t actually get None here because only c &lt; 0xA0
        // can return None, but for safety and future-proofing we do it this way
        </span>UnicodeWidthChar::width(c).unwrap_or(<span class="number">1</span>)
    }
}

<span class="comment">// lines with PSKIP, lacking PREFIX, or which are entirely blank are
// NoFormatLines; otherwise, they are FormatLines
</span><span class="attr">#[derive(Debug)]
</span><span class="kw">pub enum </span>Line {
    FormatLine(FileLine),
    NoFormatLine(String, bool),
}

<span class="kw">impl </span>Line {
    <span class="comment">// when we know that it&#39;s a FormatLine, as in the ParagraphStream iterator
    </span><span class="kw">fn </span>get_formatline(<span class="self">self</span>) -&gt; FileLine {
        <span class="kw">match </span><span class="self">self </span>{
            <span class="self">Self</span>::FormatLine(fl) =&gt; fl,
            <span class="self">Self</span>::NoFormatLine(..) =&gt; <span class="macro">panic!</span>(<span class="string">&quot;Found NoFormatLine when expecting FormatLine&quot;</span>),
        }
    }

    <span class="comment">// when we know that it&#39;s a NoFormatLine, as in the ParagraphStream iterator
    </span><span class="kw">fn </span>get_noformatline(<span class="self">self</span>) -&gt; (String, bool) {
        <span class="kw">match </span><span class="self">self </span>{
            <span class="self">Self</span>::NoFormatLine(s, b) =&gt; (s, b),
            <span class="self">Self</span>::FormatLine(..) =&gt; <span class="macro">panic!</span>(<span class="string">&quot;Found FormatLine when expecting NoFormatLine&quot;</span>),
        }
    }
}

<span class="comment">// each line&#39;s prefix has to be considered to know whether to merge it with
// the next line or not
</span><span class="attr">#[derive(Debug)]
</span><span class="kw">pub struct </span>FileLine {
    line: String,
    indent_end: usize, <span class="comment">// the end of the indent, always the start of the text
    </span>pfxind_end: usize, <span class="comment">// the end of the PREFIX&#39;s indent, that is, the spaces before the prefix
    </span>indent_len: usize, <span class="comment">// display length of indent taking into account tabs
    </span>prefix_len: usize, <span class="comment">// PREFIX indent length taking into account tabs
</span>}

<span class="comment">// iterator that produces a stream of Lines from a file
</span><span class="kw">pub struct </span>FileLines&lt;<span class="lifetime">&#39;a</span>&gt; {
    opts: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>FmtOptions,
    lines: Lines&lt;<span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="kw-2">mut </span>FileOrStdReader&gt;,
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>&gt; FileLines&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="kw">fn </span>new&lt;<span class="lifetime">&#39;b</span>&gt;(opts: <span class="kw-2">&amp;</span><span class="lifetime">&#39;b </span>FmtOptions, lines: Lines&lt;<span class="kw-2">&amp;</span><span class="lifetime">&#39;b </span><span class="kw-2">mut </span>FileOrStdReader&gt;) -&gt; FileLines&lt;<span class="lifetime">&#39;b</span>&gt; {
        FileLines { opts, lines }
    }

    <span class="comment">// returns true if this line should be formatted
    </span><span class="kw">fn </span>match_prefix(<span class="kw-2">&amp;</span><span class="self">self</span>, line: <span class="kw-2">&amp;</span>str) -&gt; (bool, usize) {
        <span class="kw">if </span>!<span class="self">self</span>.opts.use_prefix {
            <span class="kw">return </span>(<span class="bool-val">true</span>, <span class="number">0</span>);
        }

        FileLines::match_prefix_generic(<span class="kw-2">&amp;</span><span class="self">self</span>.opts.prefix[..], line, <span class="self">self</span>.opts.xprefix)
    }

    <span class="comment">// returns true if this line should be formatted
    </span><span class="kw">fn </span>match_anti_prefix(<span class="kw-2">&amp;</span><span class="self">self</span>, line: <span class="kw-2">&amp;</span>str) -&gt; bool {
        <span class="kw">if </span>!<span class="self">self</span>.opts.use_anti_prefix {
            <span class="kw">return </span><span class="bool-val">true</span>;
        }

        <span class="kw">match </span>FileLines::match_prefix_generic(
            <span class="kw-2">&amp;</span><span class="self">self</span>.opts.anti_prefix[..],
            line,
            <span class="self">self</span>.opts.xanti_prefix,
        ) {
            (<span class="bool-val">true</span>, <span class="kw">_</span>) =&gt; <span class="bool-val">false</span>,
            (<span class="kw">_</span>, <span class="kw">_</span>) =&gt; <span class="bool-val">true</span>,
        }
    }

    <span class="kw">fn </span>match_prefix_generic(pfx: <span class="kw-2">&amp;</span>str, line: <span class="kw-2">&amp;</span>str, exact: bool) -&gt; (bool, usize) {
        <span class="kw">if </span>line.starts_with(pfx) {
            <span class="kw">return </span>(<span class="bool-val">true</span>, <span class="number">0</span>);
        }

        <span class="kw">if </span>!exact {
            <span class="comment">// we do it this way rather than byte indexing to support unicode whitespace chars
            </span><span class="kw">for </span>(i, char) <span class="kw">in </span>line.char_indices() {
                <span class="kw">if </span>line[i..].starts_with(pfx) {
                    <span class="kw">return </span>(<span class="bool-val">true</span>, i);
                } <span class="kw">else if </span>!char.is_whitespace() {
                    <span class="kw">break</span>;
                }
            }
        }

        (<span class="bool-val">false</span>, <span class="number">0</span>)
    }

    <span class="kw">fn </span>compute_indent(<span class="kw-2">&amp;</span><span class="self">self</span>, string: <span class="kw-2">&amp;</span>str, prefix_end: usize) -&gt; (usize, usize, usize) {
        <span class="kw">let </span><span class="kw-2">mut </span>prefix_len = <span class="number">0</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>indent_len = <span class="number">0</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>indent_end = <span class="number">0</span>;
        <span class="kw">for </span>(os, c) <span class="kw">in </span>string.char_indices() {
            <span class="kw">if </span>os == prefix_end {
                <span class="comment">// we found the end of the prefix, so this is the printed length of the prefix here
                </span>prefix_len = indent_len;
            }

            <span class="kw">if </span>(os &gt;= prefix_end) &amp;&amp; !c.is_whitespace() {
                <span class="comment">// found first non-whitespace after prefix, this is indent_end
                </span>indent_end = os;
                <span class="kw">break</span>;
            } <span class="kw">else if </span>c == <span class="string">&#39;\t&#39; </span>{
                <span class="comment">// compute tab length
                </span>indent_len = (indent_len / <span class="self">self</span>.opts.tabwidth + <span class="number">1</span>) * <span class="self">self</span>.opts.tabwidth;
            } <span class="kw">else </span>{
                <span class="comment">// non-tab character
                </span>indent_len += char_width(c);
            }
        }
        (indent_end, prefix_len, indent_len)
    }
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>&gt; Iterator <span class="kw">for </span>FileLines&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="kw">type </span>Item = Line;

    <span class="kw">fn </span>next(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; <span class="prelude-ty">Option</span>&lt;Line&gt; {
        <span class="kw">let </span>n = <span class="kw">match </span><span class="self">self</span>.lines.next() {
            <span class="prelude-val">Some</span>(t) =&gt; <span class="kw">match </span>t {
                <span class="prelude-val">Ok</span>(tt) =&gt; tt,
                <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; <span class="kw">return </span><span class="prelude-val">None</span>,
            },
            <span class="prelude-val">None </span>=&gt; <span class="kw">return </span><span class="prelude-val">None</span>,
        };

        <span class="comment">// if this line is entirely whitespace,
        // emit a blank line
        // Err(true) indicates that this was a linebreak,
        // which is important to know when detecting mail headers
        </span><span class="kw">if </span>n.chars().all(char::is_whitespace) {
            <span class="kw">return </span><span class="prelude-val">Some</span>(Line::NoFormatLine(String::new(), <span class="bool-val">true</span>));
        }

        <span class="kw">let </span>(pmatch, poffset) = <span class="self">self</span>.match_prefix(<span class="kw-2">&amp;</span>n[..]);

        <span class="comment">// if this line does not match the prefix,
        // emit the line unprocessed and iterate again
        </span><span class="kw">if </span>!pmatch {
            <span class="kw">return </span><span class="prelude-val">Some</span>(Line::NoFormatLine(n, <span class="bool-val">false</span>));
        }

        <span class="comment">// if the line matches the prefix, but is blank after,
        // don&#39;t allow lines to be combined through it (that is,
        // treat it like a blank line, except that since it&#39;s
        // not truly blank we will not allow mail headers on the
        // following line)
        </span><span class="kw">if </span>pmatch
            &amp;&amp; n[poffset + <span class="self">self</span>.opts.prefix.len()..]
                .chars()
                .all(char::is_whitespace)
        {
            <span class="kw">return </span><span class="prelude-val">Some</span>(Line::NoFormatLine(n, <span class="bool-val">false</span>));
        }

        <span class="comment">// skip if this line matches the anti_prefix
        // (NOTE definition of match_anti_prefix is TRUE if we should process)
        </span><span class="kw">if </span>!<span class="self">self</span>.match_anti_prefix(<span class="kw-2">&amp;</span>n[..]) {
            <span class="kw">return </span><span class="prelude-val">Some</span>(Line::NoFormatLine(n, <span class="bool-val">false</span>));
        }

        <span class="comment">// figure out the indent, prefix, and prefixindent ending points
        </span><span class="kw">let </span>prefix_end = poffset + <span class="self">self</span>.opts.prefix.len();
        <span class="kw">let </span>(indent_end, prefix_len, indent_len) = <span class="self">self</span>.compute_indent(<span class="kw-2">&amp;</span>n[..], prefix_end);

        <span class="prelude-val">Some</span>(Line::FormatLine(FileLine {
            line: n,
            indent_end,
            pfxind_end: poffset,
            indent_len,
            prefix_len,
        }))
    }
}

<span class="comment">// a paragraph : a collection of FileLines that are to be formatted
// plus info about the paragraph&#39;s indentation
// (but we only retain the String from the FileLine; the other info
// is only there to help us in deciding how to merge lines into Paragraphs
</span><span class="attr">#[derive(Debug)]
</span><span class="kw">pub struct </span>Paragraph {
    lines: Vec&lt;String&gt;,     <span class="comment">// the lines of the file
    </span><span class="kw">pub </span>init_str: String,   <span class="comment">// string representing the init, that is, the first line&#39;s indent
    </span><span class="kw">pub </span>init_len: usize,    <span class="comment">// printable length of the init string considering TABWIDTH
    </span>init_end: usize,        <span class="comment">// byte location of end of init in first line String
    </span><span class="kw">pub </span>indent_str: String, <span class="comment">// string representing indent
    </span><span class="kw">pub </span>indent_len: usize,  <span class="comment">// length of above
    </span>indent_end: usize, <span class="comment">// byte location of end of indent (in crown and tagged mode, only applies to 2nd line and onward)
    </span><span class="kw">pub </span>mail_header: bool, <span class="comment">// we need to know if this is a mail header because we do word splitting differently in that case
</span>}

<span class="comment">// an iterator producing a stream of paragraphs from a stream of lines
// given a set of options.
</span><span class="kw">pub struct </span>ParagraphStream&lt;<span class="lifetime">&#39;a</span>&gt; {
    lines: Peekable&lt;FileLines&lt;<span class="lifetime">&#39;a</span>&gt;&gt;,
    next_mail: bool,
    opts: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>FmtOptions,
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>&gt; ParagraphStream&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="kw">pub fn </span>new&lt;<span class="lifetime">&#39;b</span>&gt;(opts: <span class="kw-2">&amp;</span><span class="lifetime">&#39;b </span>FmtOptions, reader: <span class="kw-2">&amp;</span><span class="lifetime">&#39;b </span><span class="kw-2">mut </span>FileOrStdReader) -&gt; ParagraphStream&lt;<span class="lifetime">&#39;b</span>&gt; {
        <span class="kw">let </span>lines = FileLines::new(opts, reader.lines()).peekable();
        <span class="comment">// at the beginning of the file, we might find mail headers
        </span>ParagraphStream {
            lines,
            next_mail: <span class="bool-val">true</span>,
            opts,
        }
    }

    <span class="comment">// detect RFC822 mail header
    </span><span class="kw">fn </span>is_mail_header(line: <span class="kw-2">&amp;</span>FileLine) -&gt; bool {
        <span class="comment">// a mail header begins with either &quot;From &quot; (envelope sender line)
        // or with a sequence of printable ASCII chars (33 to 126, inclusive,
        // except colon) followed by a colon.
        </span><span class="kw">if </span>line.indent_end &gt; <span class="number">0 </span>{
            <span class="bool-val">false
        </span>} <span class="kw">else </span>{
            <span class="kw">let </span>l_slice = <span class="kw-2">&amp;</span>line.line[..];
            <span class="kw">if </span>l_slice.starts_with(<span class="string">&quot;From &quot;</span>) {
                <span class="bool-val">true
            </span>} <span class="kw">else </span>{
                <span class="kw">let </span>colon_posn = <span class="kw">match </span>l_slice.find(<span class="string">&#39;:&#39;</span>) {
                    <span class="prelude-val">Some</span>(n) =&gt; n,
                    <span class="prelude-val">None </span>=&gt; <span class="kw">return </span><span class="bool-val">false</span>,
                };

                <span class="comment">// header field must be nonzero length
                </span><span class="kw">if </span>colon_posn == <span class="number">0 </span>{
                    <span class="kw">return </span><span class="bool-val">false</span>;
                }

                l_slice[..colon_posn]
                    .chars()
                    .all(|x| !<span class="macro">matches!</span>(x <span class="kw">as </span>usize, y <span class="kw">if </span>!(<span class="number">33</span>..=<span class="number">126</span>).contains(<span class="kw-2">&amp;</span>y)))
            }
        }
    }
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>&gt; Iterator <span class="kw">for </span>ParagraphStream&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="kw">type </span>Item = <span class="prelude-ty">Result</span>&lt;Paragraph, String&gt;;

    <span class="attr">#[allow(clippy::cognitive_complexity)]
    </span><span class="kw">fn </span>next(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; <span class="prelude-ty">Option</span>&lt;<span class="prelude-ty">Result</span>&lt;Paragraph, String&gt;&gt; {
        <span class="comment">// return a NoFormatLine in an Err; it should immediately be output
        </span><span class="kw">let </span>noformat = <span class="kw">match </span><span class="self">self</span>.lines.peek() {
            <span class="prelude-val">None </span>=&gt; <span class="kw">return </span><span class="prelude-val">None</span>,
            <span class="prelude-val">Some</span>(l) =&gt; <span class="kw">match </span><span class="kw-2">*</span>l {
                Line::FormatLine(<span class="kw">_</span>) =&gt; <span class="bool-val">false</span>,
                Line::NoFormatLine(<span class="kw">_</span>, <span class="kw">_</span>) =&gt; <span class="bool-val">true</span>,
            },
        };

        <span class="comment">// found a NoFormatLine, immediately dump it out
        </span><span class="kw">if </span>noformat {
            <span class="kw">let </span>(s, nm) = <span class="self">self</span>.lines.next().unwrap().get_noformatline();
            <span class="self">self</span>.next_mail = nm;
            <span class="kw">return </span><span class="prelude-val">Some</span>(<span class="prelude-val">Err</span>(s));
        }

        <span class="comment">// found a FormatLine, now build a paragraph
        </span><span class="kw">let </span><span class="kw-2">mut </span>init_str = String::new();
        <span class="kw">let </span><span class="kw-2">mut </span>init_end = <span class="number">0</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>init_len = <span class="number">0</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>indent_str = String::new();
        <span class="kw">let </span><span class="kw-2">mut </span>indent_end = <span class="number">0</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>indent_len = <span class="number">0</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>prefix_len = <span class="number">0</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>pfxind_end = <span class="number">0</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>p_lines = Vec::new();

        <span class="kw">let </span><span class="kw-2">mut </span>in_mail = <span class="bool-val">false</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>second_done = <span class="bool-val">false</span>; <span class="comment">// for when we use crown or tagged mode
        </span><span class="kw">loop </span>{
            {
                <span class="comment">// peek ahead
                // need to explicitly force fl out of scope before we can call self.lines.next()
                </span><span class="kw">let </span>fl = <span class="kw">match </span><span class="self">self</span>.lines.peek() {
                    <span class="prelude-val">None </span>=&gt; <span class="kw">break</span>,
                    <span class="prelude-val">Some</span>(l) =&gt; <span class="kw">match </span><span class="kw-2">*</span>l {
                        Line::FormatLine(<span class="kw-2">ref </span>x) =&gt; x,
                        Line::NoFormatLine(..) =&gt; <span class="kw">break</span>,
                    },
                };

                <span class="kw">if </span>p_lines.is_empty() {
                    <span class="comment">// first time through the loop, get things set up
                    // detect mail header
                    </span><span class="kw">if </span><span class="self">self</span>.opts.mail &amp;&amp; <span class="self">self</span>.next_mail &amp;&amp; ParagraphStream::is_mail_header(fl) {
                        in_mail = <span class="bool-val">true</span>;
                        <span class="comment">// there can&#39;t be any indent or pfxind because otherwise is_mail_header
                        // would fail since there cannot be any whitespace before the colon in a
                        // valid header field
                        </span>indent_str.push_str(<span class="string">&quot;  &quot;</span>);
                        indent_len = <span class="number">2</span>;
                    } <span class="kw">else </span>{
                        <span class="kw">if </span><span class="self">self</span>.opts.crown || <span class="self">self</span>.opts.tagged {
                            init_str.push_str(<span class="kw-2">&amp;</span>fl.line[..fl.indent_end]);
                            init_len = fl.indent_len;
                            init_end = fl.indent_end;
                        } <span class="kw">else </span>{
                            second_done = <span class="bool-val">true</span>;
                        }

                        <span class="comment">// these will be overwritten in the 2nd line of crown or tagged mode, but
                        // we are not guaranteed to get to the 2nd line, e.g., if the next line
                        // is a NoFormatLine or None. Thus, we set sane defaults the 1st time around
                        </span>indent_str.push_str(<span class="kw-2">&amp;</span>fl.line[..fl.indent_end]);
                        indent_len = fl.indent_len;
                        indent_end = fl.indent_end;

                        <span class="comment">// save these to check for matching lines
                        </span>prefix_len = fl.prefix_len;
                        pfxind_end = fl.pfxind_end;

                        <span class="comment">// in tagged mode, add 4 spaces of additional indenting by default
                        // (gnu fmt&#39;s behavior is different: it seems to find the closest column to
                        // indent_end that is divisible by 3. But honestly that behavior seems
                        // pretty arbitrary.
                        // Perhaps a better default would be 1 TABWIDTH? But ugh that&#39;s so big.
                        </span><span class="kw">if </span><span class="self">self</span>.opts.tagged {
                            indent_str.push_str(<span class="string">&quot;    &quot;</span>);
                            indent_len += <span class="number">4</span>;
                        }
                    }
                } <span class="kw">else if </span>in_mail {
                    <span class="comment">// lines following mail headers must begin with spaces
                    </span><span class="kw">if </span>fl.indent_end == <span class="number">0 </span>|| (<span class="self">self</span>.opts.use_prefix &amp;&amp; fl.pfxind_end == <span class="number">0</span>) {
                        <span class="kw">break</span>; <span class="comment">// this line does not begin with spaces
                    </span>}
                } <span class="kw">else if </span>!second_done {
                    <span class="comment">// now we have enough info to handle crown margin and tagged mode

                    // in both crown and tagged modes we require that prefix_len is the same
                    </span><span class="kw">if </span>prefix_len != fl.prefix_len || pfxind_end != fl.pfxind_end {
                        <span class="kw">break</span>;
                    }

                    <span class="comment">// in tagged mode, indent has to be *different* on following lines
                    </span><span class="kw">if </span><span class="self">self</span>.opts.tagged
                        &amp;&amp; indent_len - <span class="number">4 </span>== fl.indent_len
                        &amp;&amp; indent_end == fl.indent_end
                    {
                        <span class="kw">break</span>;
                    }

                    <span class="comment">// this is part of the same paragraph, get the indent info from this line
                    </span>indent_str.clear();
                    indent_str.push_str(<span class="kw-2">&amp;</span>fl.line[..fl.indent_end]);
                    indent_len = fl.indent_len;
                    indent_end = fl.indent_end;

                    second_done = <span class="bool-val">true</span>;
                } <span class="kw">else </span>{
                    <span class="comment">// detect mismatch
                    </span><span class="kw">if </span>indent_end != fl.indent_end
                        || pfxind_end != fl.pfxind_end
                        || indent_len != fl.indent_len
                        || prefix_len != fl.prefix_len
                    {
                        <span class="kw">break</span>;
                    }
                }
            }

            p_lines.push(<span class="self">self</span>.lines.next().unwrap().get_formatline().line);

            <span class="comment">// when we&#39;re in split-only mode, we never join lines, so stop here
            </span><span class="kw">if </span><span class="self">self</span>.opts.split_only {
                <span class="kw">break</span>;
            }
        }

        <span class="comment">// if this was a mail header, then the next line can be detected as one. Otherwise, it cannot.
        // NOTE next_mail is true at ParagraphStream instantiation, and is set to true after a blank
        // NoFormatLine.
        </span><span class="self">self</span>.next_mail = in_mail;

        <span class="prelude-val">Some</span>(<span class="prelude-val">Ok</span>(Paragraph {
            lines: p_lines,
            init_str,
            init_len,
            init_end,
            indent_str,
            indent_len,
            indent_end,
            mail_header: in_mail,
        }))
    }
}

<span class="kw">pub struct </span>ParaWords&lt;<span class="lifetime">&#39;a</span>&gt; {
    opts: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>FmtOptions,
    para: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>Paragraph,
    words: Vec&lt;WordInfo&lt;<span class="lifetime">&#39;a</span>&gt;&gt;,
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>&gt; ParaWords&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="kw">pub fn </span>new&lt;<span class="lifetime">&#39;b</span>&gt;(opts: <span class="kw-2">&amp;</span><span class="lifetime">&#39;b </span>FmtOptions, para: <span class="kw-2">&amp;</span><span class="lifetime">&#39;b </span>Paragraph) -&gt; ParaWords&lt;<span class="lifetime">&#39;b</span>&gt; {
        <span class="kw">let </span><span class="kw-2">mut </span>pw = ParaWords {
            opts,
            para,
            words: Vec::new(),
        };
        pw.create_words();
        pw
    }

    <span class="kw">fn </span>create_words(<span class="kw-2">&amp;mut </span><span class="self">self</span>) {
        <span class="kw">if </span><span class="self">self</span>.para.mail_header {
            <span class="comment">// no extra spacing for mail headers; always exactly 1 space
            // safe to trim_start on every line of a mail header, since the
            // first line is guaranteed not to have any spaces
            </span><span class="self">self</span>.words.extend(
                <span class="self">self</span>.para
                    .lines
                    .iter()
                    .flat_map(|x| x.split_whitespace())
                    .map(|x| WordInfo {
                        word: x,
                        word_start: <span class="number">0</span>,
                        word_nchars: x.len(), <span class="comment">// OK for mail headers; only ASCII allowed (unicode is escaped)
                        </span>before_tab: <span class="prelude-val">None</span>,
                        after_tab: <span class="number">0</span>,
                        sentence_start: <span class="bool-val">false</span>,
                        ends_punct: <span class="bool-val">false</span>,
                        new_line: <span class="bool-val">false</span>,
                    }),
            );
        } <span class="kw">else </span>{
            <span class="comment">// first line
            </span><span class="self">self</span>.words.extend(<span class="kw">if </span><span class="self">self</span>.opts.crown || <span class="self">self</span>.opts.tagged {
                <span class="comment">// crown and tagged mode has the &quot;init&quot; in the first line, so slice from there
                </span>WordSplit::new(<span class="self">self</span>.opts, <span class="kw-2">&amp;</span><span class="self">self</span>.para.lines[<span class="number">0</span>][<span class="self">self</span>.para.init_end..])
            } <span class="kw">else </span>{
                <span class="comment">// otherwise we slice from the indent
                </span>WordSplit::new(<span class="self">self</span>.opts, <span class="kw-2">&amp;</span><span class="self">self</span>.para.lines[<span class="number">0</span>][<span class="self">self</span>.para.indent_end..])
            });

            <span class="kw">if </span><span class="self">self</span>.para.lines.len() &gt; <span class="number">1 </span>{
                <span class="kw">let </span>indent_end = <span class="self">self</span>.para.indent_end;
                <span class="kw">let </span>opts = <span class="self">self</span>.opts;
                <span class="self">self</span>.words.extend(
                    <span class="self">self</span>.para
                        .lines
                        .iter()
                        .skip(<span class="number">1</span>)
                        .flat_map(|x| WordSplit::new(opts, <span class="kw-2">&amp;</span>x[indent_end..])),
                );
            }
        }
    }

    <span class="kw">pub fn </span>words(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="self">self</span>) -&gt; Iter&lt;<span class="lifetime">&#39;a</span>, WordInfo&lt;<span class="lifetime">&#39;a</span>&gt;&gt; {
        <span class="self">self</span>.words.iter()
    }
}

<span class="kw">struct </span>WordSplit&lt;<span class="lifetime">&#39;a</span>&gt; {
    opts: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>FmtOptions,
    string: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>str,
    length: usize,
    position: usize,
    prev_punct: bool,
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>&gt; WordSplit&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="kw">fn </span>analyze_tabs(<span class="kw-2">&amp;</span><span class="self">self</span>, string: <span class="kw-2">&amp;</span>str) -&gt; (<span class="prelude-ty">Option</span>&lt;usize&gt;, usize, <span class="prelude-ty">Option</span>&lt;usize&gt;) {
        <span class="comment">// given a string, determine (length before tab) and (printed length after first tab)
        // if there are no tabs, beforetab = -1 and aftertab is the printed length
        </span><span class="kw">let </span><span class="kw-2">mut </span>beforetab = <span class="prelude-val">None</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>aftertab = <span class="number">0</span>;
        <span class="kw">let </span><span class="kw-2">mut </span>word_start = <span class="prelude-val">None</span>;
        <span class="kw">for </span>(os, c) <span class="kw">in </span>string.char_indices() {
            <span class="kw">if </span>!c.is_whitespace() {
                word_start = <span class="prelude-val">Some</span>(os);
                <span class="kw">break</span>;
            } <span class="kw">else if </span>c == <span class="string">&#39;\t&#39; </span>{
                <span class="kw">if </span>beforetab.is_none() {
                    beforetab = <span class="prelude-val">Some</span>(aftertab);
                    aftertab = <span class="number">0</span>;
                } <span class="kw">else </span>{
                    aftertab = (aftertab / <span class="self">self</span>.opts.tabwidth + <span class="number">1</span>) * <span class="self">self</span>.opts.tabwidth;
                }
            } <span class="kw">else </span>{
                aftertab += <span class="number">1</span>;
            }
        }
        (beforetab, aftertab, word_start)
    }
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>&gt; WordSplit&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="kw">fn </span>new&lt;<span class="lifetime">&#39;b</span>&gt;(opts: <span class="kw-2">&amp;</span><span class="lifetime">&#39;b </span>FmtOptions, string: <span class="kw-2">&amp;</span><span class="lifetime">&#39;b </span>str) -&gt; WordSplit&lt;<span class="lifetime">&#39;b</span>&gt; {
        <span class="comment">// wordsplits *must* start at a non-whitespace character
        </span><span class="kw">let </span>trim_string = string.trim_start();
        WordSplit {
            opts,
            string: trim_string,
            length: string.len(),
            position: <span class="number">0</span>,
            prev_punct: <span class="bool-val">false</span>,
        }
    }

    <span class="kw">fn </span>is_punctuation(c: char) -&gt; bool {
        <span class="macro">matches!</span>(c, <span class="string">&#39;!&#39; </span>| <span class="string">&#39;.&#39; </span>| <span class="string">&#39;?&#39;</span>)
    }
}

<span class="kw">pub struct </span>WordInfo&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="kw">pub </span>word: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>str,
    <span class="kw">pub </span>word_start: usize,
    <span class="kw">pub </span>word_nchars: usize,
    <span class="kw">pub </span>before_tab: <span class="prelude-ty">Option</span>&lt;usize&gt;,
    <span class="kw">pub </span>after_tab: usize,
    <span class="kw">pub </span>sentence_start: bool,
    <span class="kw">pub </span>ends_punct: bool,
    <span class="kw">pub </span>new_line: bool,
}

<span class="comment">// returns (&amp;str, is_start_of_sentence)
</span><span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>&gt; Iterator <span class="kw">for </span>WordSplit&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="kw">type </span>Item = WordInfo&lt;<span class="lifetime">&#39;a</span>&gt;;

    <span class="kw">fn </span>next(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; <span class="prelude-ty">Option</span>&lt;WordInfo&lt;<span class="lifetime">&#39;a</span>&gt;&gt; {
        <span class="kw">if </span><span class="self">self</span>.position &gt;= <span class="self">self</span>.length {
            <span class="kw">return </span><span class="prelude-val">None</span>;
        }

        <span class="kw">let </span>old_position = <span class="self">self</span>.position;
        <span class="kw">let </span>new_line = old_position == <span class="number">0</span>;

        <span class="comment">// find the start of the next word, and record if we find a tab character
        </span><span class="kw">let </span>(before_tab, after_tab, word_start) =
            <span class="kw">match </span><span class="self">self</span>.analyze_tabs(<span class="kw-2">&amp;</span><span class="self">self</span>.string[old_position..]) {
                (b, a, <span class="prelude-val">Some</span>(s)) =&gt; (b, a, s + old_position),
                (<span class="kw">_</span>, <span class="kw">_</span>, <span class="prelude-val">None</span>) =&gt; {
                    <span class="self">self</span>.position = <span class="self">self</span>.length;
                    <span class="kw">return </span><span class="prelude-val">None</span>;
                }
            };

        <span class="comment">// find the beginning of the next whitespace
        // note that this preserves the invariant that self.position
        // points to whitespace character OR end of string
        </span><span class="kw">let </span><span class="kw-2">mut </span>word_nchars = <span class="number">0</span>;
        <span class="self">self</span>.position = <span class="kw">match </span><span class="self">self</span>.string[word_start..].find(|x: char| {
            <span class="kw">if </span>x.is_whitespace() {
                <span class="bool-val">true
            </span>} <span class="kw">else </span>{
                word_nchars += char_width(x);
                <span class="bool-val">false
            </span>}
        }) {
            <span class="prelude-val">None </span>=&gt; <span class="self">self</span>.length,
            <span class="prelude-val">Some</span>(s) =&gt; s + word_start,
        };

        <span class="kw">let </span>word_start_relative = word_start - old_position;
        <span class="comment">// if the previous sentence was punctuation and this sentence has &gt;2 whitespace or one tab, is a new sentence.
        </span><span class="kw">let </span>is_start_of_sentence =
            <span class="self">self</span>.prev_punct &amp;&amp; (before_tab.is_some() || word_start_relative &gt; <span class="number">1</span>);

        <span class="comment">// now record whether this word ends in punctuation
        </span><span class="self">self</span>.prev_punct = <span class="kw">match </span><span class="self">self</span>.string[..<span class="self">self</span>.position].chars().next_back() {
            <span class="prelude-val">Some</span>(ch) =&gt; WordSplit::is_punctuation(ch),
            <span class="kw">_ </span>=&gt; <span class="macro">panic!</span>(<span class="string">&quot;fatal: expected word not to be empty&quot;</span>),
        };

        <span class="kw">let </span>(word, word_start_relative, before_tab, after_tab) = <span class="kw">if </span><span class="self">self</span>.opts.uniform {
            (<span class="kw-2">&amp;</span><span class="self">self</span>.string[word_start..<span class="self">self</span>.position], <span class="number">0</span>, <span class="prelude-val">None</span>, <span class="number">0</span>)
        } <span class="kw">else </span>{
            (
                <span class="kw-2">&amp;</span><span class="self">self</span>.string[old_position..<span class="self">self</span>.position],
                word_start_relative,
                before_tab,
                after_tab,
            )
        };

        <span class="prelude-val">Some</span>(WordInfo {
            word,
            word_start: word_start_relative,
            word_nchars,
            before_tab,
            after_tab,
            sentence_start: is_start_of_sentence,
            ends_punct: <span class="self">self</span>.prev_punct,
            new_line,
        })
    }
}
</code></pre></div></section></main></body></html>